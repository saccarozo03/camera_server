# app/recorder.py
import threading
import time
import shutil
from pathlib import Path
from typing import Tuple, List, Any
from datetime import datetime

import cv2

from .config import PRE_SECONDS, POST_SECONDS, FPS_TARGET, FOURCC
from .logging_utils import log
from .camera import (
    get_current_fps,
    get_latest_frame_raw,
    get_buffer_snapshot,
    get_items_after,
)

LOCAL_VIDEO_DIR = Path("/mnt/ssd/camera_videos")
REMOTE_ROOT_DIR = Path("/mnt/denso247")
LOCAL_VIDEO_DIR.mkdir(parents=True, exist_ok=True)

record_threads: List[threading.Thread] = []


def _copy_to_share(local_path: Path, max_retry: int = 3, retry_sleep: float = 2.0) -> Tuple[bool, str]:
    date_str = datetime.now().strftime("%Y-%m-%d")
    remote_day_dir = REMOTE_ROOT_DIR / date_str

    try:
        remote_day_dir.mkdir(parents=True, exist_ok=True)
    except Exception as e:
        return False, f"Cannot create remote day directory {remote_day_dir}: {e}"

    remote_path = remote_day_dir / local_path.name

    last_err = ""
    for attempt in range(1, max_retry + 1):
        try:
            shutil.copy2(local_path, remote_path)
            return True, f"Copied to {remote_path}"
        except Exception as e:
            last_err = str(e)
            log(f"[UPLOAD][RETRY {attempt}/{max_retry}] {last_err}")
            time.sleep(retry_sleep)

    return False, f"Copy failed after {max_retry} retries: {last_err}"


def _decode_jpeg(enc: Any) -> Any:
    # enc là numpy 1D do cv2.imencode trả về
    frame = cv2.imdecode(enc, cv2.IMREAD_COLOR)
    return frame


def _record_event(pre_items: List[Tuple[float, Any]], width: int, height: int, anchor_ts: float) -> None:
    """
    Ghi video:
      - PRE: theo pre_items (timestamp + jpeg) đã cắt theo anchor_ts
      - POST: drain theo timestamp từ anchor_ts đến anchor_ts + POST_SECONDS
    """
    fps = get_current_fps()
    if fps <= 0:
        fps = float(FPS_TARGET)

    timestamp = int(time.time())
    local_path = LOCAL_VIDEO_DIR / f"video_{timestamp}.mp4"

    writer = cv2.VideoWriter(str(local_path), FOURCC, fps, (width, height))
    if not writer.isOpened():
        log("[ERROR] Cannot create local video file")
        return

    log(f"[REC] Start recording local: {local_path} (fps={fps:.2f})")
    if pre_items:
        log(f"[REC] PRE count={len(pre_items)} span~{pre_items[-1][0] - pre_items[0][0]:.2f}s")

    # ===== PRE =====
    for _, enc in pre_items:
        fr = _decode_jpeg(enc)
        if fr is None:
            continue
        # đảm bảo đúng size writer
        if fr.shape[1] != width or fr.shape[0] != height:
            fr = cv2.resize(fr, (width, height))
        writer.write(fr)

    # ===== POST (drain by timestamp) =====
    end_ts = anchor_ts + POST_SECONDS
    last_written_ts = anchor_ts

    log(f"[REC] POST drain from {anchor_ts:.3f} to {end_ts:.3f}")

    idle = 0
    while last_written_ts < end_ts:
        new_items = get_items_after(last_written_ts)

        if new_items:
            for ts, enc in new_items:
                # chỉ ghi tới end_ts
                if ts > end_ts:
                    last_written_ts = end_ts
                    break

                fr = _decode_jpeg(enc)
                if fr is None:
                    continue
                if fr.shape[1] != width or fr.shape[0] != height:
                    fr = cv2.resize(fr, (width, height))

                writer.write(fr)
                last_written_ts = ts

            idle = 0
        else:
            idle += 1
            time.sleep(0.003)

            # Log nếu camera bị đứng hoặc recorder không nhận frame mới
            if idle % 500 == 0:
                remain = end_ts - last_written_ts
                log(f"[REC][WARN] No new frames yet. remain~{remain:.2f}s")

    writer.release()
    log(f"[REC] Done recording local: {local_path}")

    ok, msg = _copy_to_share(local_path, max_retry=3, retry_sleep=2.0)
    if ok:
        log(f"[UPLOAD] {msg}")
    else:
        log(f"[UPLOAD][ERROR] {msg}")


def trigger_event() -> Tuple[bool, str]:
    """
    Trigger:
      - anchor_ts = timestamp của frame mới nhất trong buffer tại thời điểm trigger
      - PRE cắt theo anchor_ts (không dùng time.time để tránh lệch)
      - POST drain từ anchor_ts -> anchor_ts + POST_SECONDS (không hụt giây)
    """
    buf = get_buffer_snapshot()
    if not buf:
        return False, "Buffer is empty"

    # anchor_ts = frame mới nhất hiện có
    anchor_ts = buf[-1][0]

    # Kiểm tra buffer có đủ pre không
    if (anchor_ts - buf[0][0]) < PRE_SECONDS:
        return False, "Buffer not full yet"

    # Cắt PRE theo anchor_ts
    pre_items = [(ts, enc) for (ts, enc) in buf if (anchor_ts - PRE_SECONDS) <= ts <= anchor_ts]

    # Lấy kích thước từ latest raw (nhẹ), fallback decode 1 frame nếu cần
    lf = get_latest_frame_raw()
    if lf is not None:
        h, w = lf.shape[:2]
    else:
        # fallback: decode frame cuối
        fr = _decode_jpeg(buf[-1][1])
        if fr is None:
            return False, "Cannot decode frame"
        h, w = fr.shape[:2]

    log(f"[TRIGGER] anchor_ts={anchor_ts:.3f}, pre_count={len(pre_items)}")

    t = threading.Thread(
        target=_record_event,
        args=(pre_items, w, h, anchor_ts),
        daemon=False,
    )
    t.start()
    record_threads.append(t)

    log("[TRIGGER] Recording triggered")
    return True, "Recording started"
